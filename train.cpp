#include "train.hpp"
#include "car.hpp"

/**
 * \brief Constructor for train, initializes member variables
 * of a train object
 * \param the train type, either BASIC or SMART
 * \returns void
 **/
Train::Train(traintype type) :
cars_{new Car[1]},
numCars_{1},
usage_{0},
revenue_{0},
operatingCost_{0},
type_{type} {
}

/**
 * \brief Train object destructor, deallocates heap memory
 * and destroys data in memory for a train.
 * and update member variable binsInUse_ appropriately
 * \param Train object
 * \returns void
 **/
Train::~Train() {
    delete []cars_;
}

/**
 * \brief Changes the length of a Train by creating
 * a new Train of new length and transferring the 
 * contents of the old train to the new one. 
 * \param Train object, size of the new train
 * \returns void
 **/
void Train::changeSize(size_t size) {
    Car *oldCars = cars_;
    size_t numOldCars = numCars_;

    cars_ = new Car[size];
    numCars_ = size;
    usage_ = 0;
    /*
    * Iterates through old train and transfers 
    * packages from old train to memory
    * location of the new train.
    */
    for (size_t i = 0; i < numOldCars; ++i) {
        while (oldCars[i].isEmpty() == false) {
            oldCars[i].removePackage();
            loadPackage();
        }
    }
    delete []oldCars;
}

/**
 * \brief Increases the length of a Train by calling the
 * changeSize function. New size depends on the train
 * type: BASIC trains change size by BASIC_SIZE_CHANGE increment,
 * while SMART trains change by a multiple of SMART_SIZE_CHANGE. 
 * \param Train object
 * \returns void
 **/
void Train::upsizeIfNeeded() {
    if (usage_ == Car::CAPACITY*numCars_) {
        if (type_ == BASIC) {
            changeSize(numCars_+BASIC_SIZE_CHANGE);
        } else {
             changeSize(numCars_*SMART_SIZE_CHANGE);
        }
    }
}

/**
 * \brief Decreases the length of a Train by calling the
 * changeSize function. New size depends on the train
 * type: BASIC trains change size by BASIC_SIZE_CHANGE decrement,
 * while SMART trains change by a fraction of SMART_SIZE_CHANGE. 
 * \param Train object
 * \returns void
 **/
void Train::downsizeIfNeeded() {
    if (numCars_ > 1) {
        if (type_ == BASIC && cars_[numCars_-1].isEmpty()) {
            changeSize(numCars_-BASIC_SIZE_CHANGE);
        } else if (type_ == SMART &&
                usage_ <= Car::CAPACITY*numCars_/SMART_DOWNSIZE_THRESHOLD) {
             changeSize(numCars_/SMART_SIZE_CHANGE);
        }
    }
}

/**
 * \brief Adds a package to the end of a train and increases the train's
 * length if needed. Additionally, logs the revenue generated
 * by adding SHIPPING_COST every time the function is called. 
 * \param Train object
 * \returns void
 **/
void Train::addPackage() {
    upsizeIfNeeded();
    loadPackage();
    revenue_ += SHIPPING_COST;
}

/**
 * \brief Removes a package from the last loaded car in 
 * a train and updates the train's usage accordingly. 
 * Additionally, downsizes the train if possible.  
 * \param Train object
 * \returns void
 **/
void Train::removePackage() {
    if (usage_ > 0) {
        usage_ -= 1;
        size_t firstNonEmpty = usage_ / Car::CAPACITY;
        cars_[firstNonEmpty].removePackage();
        downsizeIfNeeded();
    }
}

/**
 * \brief Loads a package into the first empty car in a Train.
 * Additionally, logs the revenue generated by adding 
 * SHIPPING_COST every time the function is called. 
 * \param Train object
 * \returns void
 **/
void Train::loadPackage() {
    size_t firstEmpty = usage_ / Car::CAPACITY;
    if (firstEmpty < numCars_) {
        cars_[firstEmpty].addPackage();
        usage_ += 1;
        operatingCost_ += HANDLING_COST;
    }
}

/**
 * \brief Print statement for Train object. Prints a slew
 * of Car objects from the train to the Terminal in ASCII characters
 * showing where the train cars are linked and whether or not they
 * are full. 
 * \param reference to ostream string object, reference to train object
 * \returns ostream string object
 **/
std::ostream& operator<<(std::ostream& os, const Train& t) {
    os << "(" << t.revenue_ << ", " << t.operatingCost_ << ") ";
    for (size_t i = 0; i < t.numCars_; ++i) {
        os << t.cars_[i];
    }
    return os;
}
